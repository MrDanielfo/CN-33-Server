{"version":3,"sources":["../../src/actions/userActions.js"],"names":["Date","prototype","addDays","days","date","valueOf","setDate","getDate","createToken","user","exp","getTime","payload","_id","email","name","token","jwt","sign","SECRET","createUser","UserModel","create","newUser","getUsers","find","console","log","updateUser","filter","update","modified","findOneAndUpdate","doLoginAction","password","findOne","bcrypt","compare","passwordb","findUser"],"mappings":"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","sourcesContent":["import jwt from 'jsonwebtoken';\r\nimport bcrypt from 'bcrypt';\r\n\r\nimport { SECRET } from '../config/index';\r\n\r\nimport  { UserModel }  from '../database/models/index';\r\n\r\n// creamos una funcion para Date que nos regresa un nuevo date con N numero de dias agregados.\r\nDate.prototype.addDays = function (days) {\r\n  const date = new Date(this.valueOf());\r\n  date.setDate(date.getDate() + days);\r\n  return date;\r\n}\r\n\r\n// creamos una funcion que recibe la data del usuario y genera un token nuevo con fecha de expiracion\r\n// paso 1 - crea una fecha de expiracion\r\n// paso 2 - crea un payload para el token con base a la informacion del usuario\r\n// paso 3 - regresa un token firmado por nuesto servidor con base en una clave secreta\r\nconst createToken = (user) => {\r\n  const exp = new Date().addDays(3).getTime();\r\n  const payload = {\r\n    _id: user._id,\r\n    email: user.email,\r\n    name: user.name,\r\n    exp,\r\n  };\r\n  // const token = jwt.sign(payload, process.env.SECRET);\r\n  const token = jwt.sign(payload, SECRET);\r\n  return { token }\r\n}\r\n\r\n// userActions GRAPHQL\r\nexport const createUser = async (user) => {\r\n   try {\r\n     const newUser = await UserModel.create(user);\r\n     const token = createToken(newUser);\r\n     return token;\r\n   } catch(err) {\r\n     return null;\r\n   }\r\n};\r\n\r\nexport const getUsers = async () => {\r\n    try {\r\n        return await UserModel.find();\r\n    } catch (err) {\r\n        console.log(err)\r\n    }\r\n};\r\n\r\nexport const updateUser = async (filter, update) => {\r\n  // ver el { new: true }\r\n  try {\r\n    const modified = UserModel.findOneAndUpdate(filter, update, { new: true });\r\n    return await modified;\r\n  } catch (err) {\r\n      return err;\r\n  }\r\n\r\n}\r\n\r\n// Login User with JWT y bcrypt\r\n\r\n// loginAction - funcion que loguea al usuario, si sus credenciales son correctas te envia un login de autenticacion.\r\n// Paso 1 - creamos una promesa.\r\n// Paso 2 - buscamos en la base de datos un usario con un email en especifico\r\n// Paso 3 - si existe el usuario comparamos el password ingresado con el password en la base de datos(encriptada)\r\n// Paso 4 - si es valida la comparacion regresa un token con un mensaje\r\n// Paso 5 - si alguna validacion falla o hay algun error regresa un error\r\n\r\n export const doLoginAction = async (email, password) => {\r\n   try {\r\n\r\n     const user = await UserModel.findOne({ email: email })\r\n     if (user) {\r\n       const passwordb = await bcrypt.compare(password, user.password);\r\n       if (passwordb) {\r\n         let token = createToken(user);\r\n         return token;\r\n       } else {\r\n         let token = null;\r\n         return token;\r\n       }\r\n     } \r\n    \r\n   } catch (err) {\r\n      console.log(err)\r\n   }\r\n  \r\n }\r\n\r\nexport const findUser = async (filter) => {\r\n  try {\r\n    return await UserModel.findOne(filter);\r\n  } catch (error) {\r\n    return error;\r\n  }\r\n}\r\n"],"file":"userActions.js"}